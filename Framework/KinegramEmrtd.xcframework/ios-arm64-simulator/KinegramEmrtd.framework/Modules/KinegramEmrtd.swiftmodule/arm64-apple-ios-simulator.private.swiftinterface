// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.1.2 effective-5.10 (swiftlang-6.1.2.1.2 clang-1700.0.13.5)
// swift-module-flags: -target arm64-apple-ios15.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -module-name KinegramEmrtd
// swift-module-flags-ignorable: -no-verify-emitted-module-interface -interface-compiler-version 6.1.2
import CommonCrypto
import CoreNFC
import CryptoKit
import Foundation
import Swift
import UIKit
import _Concurrency
import _CoreNFC_UIKit
import _StringProcessing
import _SwiftConcurrencyShims
public enum ASN1Error : KinegramEmrtd.ErrorWithMonitoringInfo {
  case FailedToDecodeLength(_: Swift.String)
  case FailedToReadValue(_: Swift.String)
  case FailedToDecodeTagNumber(_: Swift.String)
  case FailedToEncodeLength(_: Swift.Int)
  case FailedToDecodeObjectIdentifier(_: Swift.String)
  public var monitoringText: Swift.String {
    get
  }
}
public enum ASN1TagClass : Swift.UInt8 {
  case Universal
  case Application
  case ContextSpecific
  case Private
  case Unknown
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public struct ASN1Tag : Swift.Equatable, Swift.CustomDebugStringConvertible, Swift.Hashable {
  public let cls: KinegramEmrtd.ASN1TagClass
  public let primitive: Swift.Bool
  public let number: Swift.UInt64
  public var constructed: Swift.Bool {
    get
  }
  public let rawBytes: Swift.ArraySlice<Swift.UInt8>
  public static func == (lhs: KinegramEmrtd.ASN1Tag, rhs: KinegramEmrtd.ASN1Tag) -> Swift.Bool
  public static func == (lhs: KinegramEmrtd.ASN1Tag, rhs: [Swift.UInt8]) -> Swift.Bool
  public var debugDescription: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias ASN1TLV = (rawBytes: Swift.ArraySlice<Swift.UInt8>, tag: KinegramEmrtd.ASN1Tag, length: Swift.Int, value: Swift.ArraySlice<Swift.UInt8>)
public struct ASN1Integer : Swift.Hashable {
  public let rawBytes: [Swift.UInt8]
  public let int: Swift.Int64?
  public static func == (a: KinegramEmrtd.ASN1Integer, b: KinegramEmrtd.ASN1Integer) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ASN1ObjectIdentifier : Swift.Hashable {
  public let rawBytes: [Swift.UInt8]
  public let string: Swift.String
  public static func == (a: KinegramEmrtd.ASN1ObjectIdentifier, b: KinegramEmrtd.ASN1ObjectIdentifier) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol AccessKey {
  var type: Swift.UInt8 { get }
  var keyString: Swift.String { get }
}
public struct MRZKey : KinegramEmrtd.AccessKey {
  public var type: Swift.UInt8 {
    get
  }
  public var keyString: Swift.String {
    get
  }
  public init(documentNumber: Swift.String, birthDateyyMMdd: Swift.String, expiryDateyyMMdd: Swift.String)
  public init(documentNumber: Swift.String, birthDate: Foundation.Date, expiryDate: Foundation.Date)
}
public struct CANKey : KinegramEmrtd.AccessKey {
  public var type: Swift.UInt8 {
    get
  }
  public let keyString: Swift.String
  @available(*, deprecated, message: "Use init(can:) instead.")
  public init(keyString: Swift.String)
  public init(can: Swift.String)
}
@_hasMissingDesignatedInitializers @_documentation(visibility: internal) public class Bignum {
  public init(_ dec: Swift.String)
  public init(hex: Swift.String)
  convenience public init(_ value: Swift.Int32 = 0)
  convenience public init(data: [Swift.UInt8])
  @objc deinit
  public var isOdd: Swift.Bool {
    get
  }
  public var bitLength: Swift.Int32 {
    get
  }
  public var data: [Swift.UInt8]? {
    get
  }
  public var dec: Swift.String {
    get
  }
  public var hex: Swift.String {
    get
  }
  public var intValue: Swift.Int32? {
    get
  }
}
extension KinegramEmrtd.Bignum : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension KinegramEmrtd.Bignum : Swift.Comparable {
  public static func == (lhs: KinegramEmrtd.Bignum, rhs: KinegramEmrtd.Bignum) -> Swift.Bool
  public static func == (lhs: KinegramEmrtd.Bignum, rhs: Swift.Int32) -> Swift.Bool
  public static func < (lhs: KinegramEmrtd.Bignum, rhs: KinegramEmrtd.Bignum) -> Swift.Bool
  public static func < (lhs: KinegramEmrtd.Bignum, rhs: Swift.Int32) -> Swift.Bool
}
@_documentation(visibility: internal) public func exp(_ a: KinegramEmrtd.Bignum, _ p: KinegramEmrtd.Bignum, mod: KinegramEmrtd.Bignum) -> KinegramEmrtd.Bignum
@_documentation(visibility: internal) public func exp(_ a: KinegramEmrtd.Bignum, _ p: Swift.Int32, mod: KinegramEmrtd.Bignum) -> KinegramEmrtd.Bignum
@_documentation(visibility: internal) public func sqr(_ a: KinegramEmrtd.Bignum, mod: KinegramEmrtd.Bignum) -> KinegramEmrtd.Bignum
@_documentation(visibility: internal) public func add(_ a: KinegramEmrtd.Bignum, _ b: KinegramEmrtd.Bignum, mod: KinegramEmrtd.Bignum) -> KinegramEmrtd.Bignum
@_documentation(visibility: internal) public func mul(_ a: KinegramEmrtd.Bignum, _ b: KinegramEmrtd.Bignum, mod: KinegramEmrtd.Bignum) -> KinegramEmrtd.Bignum
@_documentation(visibility: internal) public func % (lhs: KinegramEmrtd.Bignum, rhs: KinegramEmrtd.Bignum) -> KinegramEmrtd.Bignum
@_documentation(visibility: internal) public func % (lhs: KinegramEmrtd.Bignum, rhs: Swift.Int32) -> Swift.Int32
@_documentation(visibility: internal) public func * (lhs: KinegramEmrtd.Bignum, rhs: KinegramEmrtd.Bignum) -> KinegramEmrtd.Bignum
@_documentation(visibility: internal) public func * (lhs: Swift.Int32, rhs: KinegramEmrtd.Bignum) -> KinegramEmrtd.Bignum
@_documentation(visibility: internal) public func + (lhs: KinegramEmrtd.Bignum, rhs: KinegramEmrtd.Bignum) -> KinegramEmrtd.Bignum
@_documentation(visibility: internal) public func + (lhs: Swift.Int32, rhs: KinegramEmrtd.Bignum) -> KinegramEmrtd.Bignum
@_documentation(visibility: internal) public func + (lhs: KinegramEmrtd.Bignum, rhs: Swift.Int32) -> KinegramEmrtd.Bignum
@_documentation(visibility: internal) public func - (lhs: KinegramEmrtd.Bignum, rhs: KinegramEmrtd.Bignum) -> KinegramEmrtd.Bignum
@_documentation(visibility: internal) public func - (lhs: Swift.Int32, rhs: KinegramEmrtd.Bignum) -> KinegramEmrtd.Bignum
@_documentation(visibility: internal) public func - (lhs: KinegramEmrtd.Bignum, rhs: Swift.Int32) -> KinegramEmrtd.Bignum
@_documentation(visibility: internal) public func / (lhs: KinegramEmrtd.Bignum, rhs: KinegramEmrtd.Bignum) -> KinegramEmrtd.Bignum
@_documentation(visibility: internal) public func / (lhs: Swift.Int32, rhs: KinegramEmrtd.Bignum) -> KinegramEmrtd.Bignum
@_documentation(visibility: internal) public func / (lhs: KinegramEmrtd.Bignum, rhs: Swift.Int32) -> KinegramEmrtd.Bignum
@available(*, deprecated, message: "Access the X509Wrapper properties instead.")
@_documentation(visibility: internal) public enum CertificateItem : Swift.String {
  case fingerprint
  case issuerName
  case subjectName
  case serialNumber
  case signatureAlgorithm
  case publicKeyParams
  case notBefore
  case notAfter
  public init?(rawValue: Swift.String)
  @available(*, deprecated, message: "Access the X509Wrapper properties instead.")
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension KinegramEmrtd.X509Wrapper {
  @available(*, deprecated, message: "Access the X509Wrapper properties instead.")
  public func getItemsAsDict() -> [KinegramEmrtd.CertificateItem : Swift.String]
}
@_documentation(visibility: internal) public class X509Wrapper {
  final public let cert: Swift.OpaquePointer
  public init(withCopyOf cert: Swift.OpaquePointer)
  @objc deinit
  public func getDERBinary() throws -> [Swift.UInt8]
  public var fingerprint: Swift.String? {
    get
  }
  public var notBeforeDate: Swift.String? {
    get
  }
  public var notAfterDate: Swift.String? {
    get
  }
  public var serialNumber: Swift.String? {
    get
  }
  public var signatureAlgorithm: Swift.String? {
    get
  }
  public var publicKeyParams: Swift.String? {
    get
  }
  public var issuerName: Swift.String? {
    get
  }
  public var subjectName: Swift.String? {
    get
  }
}
public typealias EmrtdPassportReader = KinegramEmrtd.EmrtdReader
public typealias EmrtdPassportReaderError = KinegramEmrtd.EmrtdReaderError
@objc @_inheritsConvenienceInitializers public class EmrtdReader : ObjectiveC.NSObject {
  public var errorLocalization: (_ error: KinegramEmrtd.EmrtdReaderError) -> Swift.String
  public var stepLocalization: (_ currentStep: KinegramEmrtd.ReadAndVerifyStep) -> Swift.String
  public var fileReadProgressLocalization: (_ currentFile: KinegramEmrtd.ElementaryFileName, _ readBytes: Swift.Int, _ totalBytes: Swift.Int) -> Swift.String
  public init(errorLocalization: ((KinegramEmrtd.EmrtdReaderError) -> Swift.String)? = nil, stepLocalization: ((KinegramEmrtd.ReadAndVerifyStep) -> Swift.String)? = nil, fileReadProgressLocalization: ((_ currentFile: KinegramEmrtd.ElementaryFileName, _ readBytes: Swift.Int, _ totalBytes: Swift.Int) -> Swift.String)? = nil)
  public func readMasterlist(from masterListUrl: Foundation.URL, masterlistIssuerCertificateUrl: Foundation.URL? = nil) throws
  public func read(accessKey: any KinegramEmrtd.AccessKey, usePACEPolling: Swift.Bool = false) async throws -> KinegramEmrtd.EmrtdResult
  public func readAndVerify(accessKey: any KinegramEmrtd.AccessKey, usePACEPolling: Swift.Bool = false) async throws -> KinegramEmrtd.EmrtdResult
  @_documentation(visibility: internal) public func startWithHandover(accessKey: any KinegramEmrtd.AccessKey, activeAuthChallenge: Foundation.Data? = nil, apduRelayHandler: (any KinegramEmrtd.APDURelayHandler)? = nil, usePACEPolling: Swift.Bool = false) async throws -> KinegramEmrtd.HandoverState
  @_documentation(visibility: internal) public func sendExternalAPDU(_ commandData: Foundation.Data) async throws -> Foundation.Data
  @_documentation(visibility: internal) public func closeSession()
  @_documentation(visibility: internal) public func invalidateSession(errorMessage: Swift.String? = nil)
  @_documentation(visibility: internal) public func continueAfterHandback(from state: KinegramEmrtd.HandoverState, handbackInfo: KinegramEmrtd.CAHandbackInfo, filesToRead: KinegramEmrtd.DataGroupSet = .standard, shouldAutoInvalidateSession: Swift.Bool = true, usePACEPolling: Swift.Bool = false) async throws -> KinegramEmrtd.EmrtdResult
  @objc deinit
}
indirect public enum ReadAndVerifyStep {
  case waitingForPassport
  case readFileAtrInfo
  case readFileCardAccess
  case doPaceOrBac(continueWith: KinegramEmrtd.ReadAndVerifyStep)
  case readFileSOD
  case readFileDG14
  case doChipAuthenticationIfAvailable(dg14File: KinegramEmrtd.File)
  case readFileDG15
  case doActiveAuthentication(dg15File: KinegramEmrtd.File)
  case readRemainingElementaryFiles
  case doPassiveAuthentication
  case done
  case readFile(KinegramEmrtd.ElementaryFileName)
  public var description: Swift.String {
    get
  }
}
public enum EmrtdReaderError : KinegramEmrtd.ErrorWithMonitoringInfo {
  case NFCNotSupported(CoreNFC.NFCTagReaderSession.PollingOption)
  case MoreThanOneTagFound
  case WrongTag
  case UserInvalidatedSession
  case SessionInvalidated(CoreNFC.NFCReaderError.Code?)
  case ConnectingFailed((any Swift.Error)?)
  case ConnectionLost
  case PaceOrBacFailed((any Swift.Error)?)
  case FileReadFailed(KinegramEmrtd.EmrtdChipCommunicationError?, [KinegramEmrtd.ElementaryFileName])
  case IncompleteRead([KinegramEmrtd.ElementaryFileName])
  case IncorrectAccessKey(Swift.UInt8)
  case InvalidHandoverData
  case ChipAuthenticationFailed
  case PACEPollingNotAvailable
  public var errorDescription: Swift.String {
    get
  }
  public var monitoringText: Swift.String {
    get
  }
}
public enum MasterlistReadError : KinegramEmrtd.ErrorWithMonitoringInfo {
  case FailedToReadMasterlistFile(any Swift.Error)
  public var errorDescription: Swift.String {
    get
  }
  public var monitoringText: Swift.String {
    get
  }
}
extension KinegramEmrtd.EmrtdResult {
  public static func generateMockSampleInstance(files: [KinegramEmrtd.ElementaryFileName : Foundation.Data], masterlist: KinegramEmrtd.MasterlistFile? = nil) throws -> KinegramEmrtd.EmrtdResult
}
public enum VerificationResult<T> : Swift.Equatable where T : Swift.Equatable {
  case Unavailable
  case Aborted(failedToParseFile: KinegramEmrtd.ElementaryFileName)
  case Failed(reason: T)
  case Success
  public static func == (a: KinegramEmrtd.VerificationResult<T>, b: KinegramEmrtd.VerificationResult<T>) -> Swift.Bool
}
public typealias EmrtdPassport = KinegramEmrtd.EmrtdResult
@_hasMissingDesignatedInitializers public class EmrtdResult {
  public var allReadFiles: [KinegramEmrtd.ElementaryFileName : KinegramEmrtd.File] {
    get
  }
  public var chipAccessProtocolType: KinegramEmrtd.ChipAccessType? {
    get
  }
  public var chipAccessResult: Swift.Bool? {
    get
  }
  public var chipAuthenticationResult: KinegramEmrtd.VerificationResult<KinegramEmrtd.ChipAuthenticationFailedReason>? {
    get
  }
  public var activeAuthenticationResult: KinegramEmrtd.VerificationResult<KinegramEmrtd.ActiveAuthenticationFailedReason>? {
    get
  }
  public var activeAuthenticationSignature: Foundation.Data? {
    get
  }
  public var issuerCertificate: KinegramEmrtd.X509Wrapper? {
    get
  }
  public var validHashFiles: [KinegramEmrtd.File] {
    get
  }
  public var cardAccessFileAuthenticityConfirmed: Swift.Bool? {
    get
  }
  public var passiveAuthenticationErrors: [KinegramEmrtd.PassiveAuthenticationError] {
    get
  }
  public var cardAccessFile: KinegramEmrtd.CardAccessFile? {
    get
  }
  public var sodFile: KinegramEmrtd.SODFile? {
    get
  }
  public var dg1File: KinegramEmrtd.DataGroup1File? {
    get
  }
  public var dg2File: KinegramEmrtd.DataGroup2File? {
    get
  }
  public var dg7File: KinegramEmrtd.DataGroup7File? {
    get
  }
  public var dg11File: KinegramEmrtd.DataGroup11File? {
    get
  }
  public var dg12File: KinegramEmrtd.DataGroup12File? {
    get
  }
  public var dg14File: KinegramEmrtd.DataGroup14File? {
    get
  }
  public var dg15File: KinegramEmrtd.DataGroup15File? {
    get
  }
  public var notCorrectlyParsedFiles: [KinegramEmrtd.File] {
    get
  }
  public var passiveAuthenticationResult: Swift.Bool? {
    get
  }
  public var allHashesValid: Swift.Bool {
    get
  }
  @objc deinit
}
public protocol ErrorWithMonitoringInfo : Swift.Error {
  var monitoringText: Swift.String { get }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class BiometricFace : KinegramEmrtd.Biometric {
  final public let version: Swift.String
  final public let faceImageInfos: [KinegramEmrtd.BiometricFaceImageInfo]
  @objc deinit
}
public enum Gender : Swift.Int {
  case Unspecified
  case Male
  case Female
  case Unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum EyeColor : Swift.Int {
  case Unspecified
  case Black
  case Blue
  case Brown
  case Gray
  case Green
  case MultiColored
  case Pink
  case Unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum HairColor : Swift.Int {
  case Unspecified
  case Bald
  case Black
  case Blonde
  case Brown
  case Gray
  case White
  case Red
  case Green
  case Blue
  case Unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct Features {
  public enum Flag : Swift.UInt32 {
    case Glasses
    case Moustache
    case Beard
    case TeethVisible
    case Blink
    case MouthOpen
    case LeftEyePatch
    case RightEyePatch
    case DarkGlasses
    case DistortingMedicalCondition
    public init?(rawValue: Swift.UInt32)
    public typealias RawValue = Swift.UInt32
    public var rawValue: Swift.UInt32 {
      get
    }
  }
  public let featureMask: Swift.UInt32
  public func hasFeature(featureFlag: KinegramEmrtd.Features.Flag) -> Swift.Bool
}
public enum Expression : Swift.Int {
  case Unspecified
  case Neutral
  case SmileClosed
  case SmileOpen
  case RaisedEyebrows
  case EyesLookingAway
  case Squinting
  case Frowning
  case Unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum FaceImageType : Swift.Int {
  case Basic
  case FullFrontal
  case TokenFrontal
  case Unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum ImageDataType : Swift.Int {
  case JPEG
  case JPEG2000
  case Unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum ColorSpace : Swift.Int {
  case Unspecified
  case RGB24
  case YUV422
  case Gray8
  case Other
  case Unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum SourceType : Swift.Int {
  case Unspecified
  case StaticPhotoUnknownSource
  case StaticPhotoDigitalCam
  case StaticPhotoScanner
  case VideoFrameUnknownSource
  case VideoFrameAnalogCam
  case VideoFrameDigitalCam
  case Unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public typealias BiometricAngle = (yaw: Swift.UInt8, pitch: Swift.UInt8, roll: Swift.UInt8)
public typealias BiometricFeaturePoint = (type: Swift.UInt8, point: Swift.UInt8, x: Swift.UInt16, y: Swift.UInt16)
public struct BiometricFaceImageInfo {
  public let recordLength: Swift.UInt32
  public let gender: KinegramEmrtd.Gender
  public let eyeColor: KinegramEmrtd.EyeColor
  public let hairColor: KinegramEmrtd.HairColor
  public let features: KinegramEmrtd.Features?
  public let expression: KinegramEmrtd.Expression
  public let poseAngle: KinegramEmrtd.BiometricAngle
  public let poseAngleUncertainty: KinegramEmrtd.BiometricAngle
  public let featurePoints: [KinegramEmrtd.BiometricFeaturePoint]
  public let faceImageType: KinegramEmrtd.FaceImageType
  public let imageDataType: KinegramEmrtd.ImageDataType
  public let width: Swift.UInt16
  public let height: Swift.UInt16
  public let colorspace: KinegramEmrtd.ColorSpace
  public let sourceType: KinegramEmrtd.SourceType
  public let deviceType: Swift.UInt16
  public let quality: Swift.UInt16
  public let rawImageData: [Swift.UInt8]
  public let uiImage: UIKit.UIImage?
}
public enum BiometricError : KinegramEmrtd.ErrorWithMonitoringInfo {
  case InvalidFormat
  public var monitoringText: Swift.String {
    get
  }
  public static func == (a: KinegramEmrtd.BiometricError, b: KinegramEmrtd.BiometricError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct BiometricInformation<T> where T : KinegramEmrtd.Biometric {
  public let header: [KinegramEmrtd.ASN1Tag : [Swift.UInt8]]
  public let biometric: T
}
@_hasMissingDesignatedInitializers public class Biometric {
  @objc deinit
}
@_hasMissingDesignatedInitializers public class File {
  final public let fileName: KinegramEmrtd.ElementaryFileName
  final public let data: [Swift.UInt8]
  final public let parsingError: (any Swift.Error)?
  @objc deinit
}
@_hasMissingDesignatedInitializers public class AtrInfoFile : KinegramEmrtd.File {
  public var maxCommandBytes: Swift.Int? {
    get
  }
  public var maxResponseBytes: Swift.Int? {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class CardAccessFile : KinegramEmrtd.File {
  final public let paceInfos: [KinegramEmrtd.PaceInfo]
  final public let paceDomainParameterInfos: [KinegramEmrtd.PaceDomainParameterInfo]
  final public let chipAuthenticationInfos: [KinegramEmrtd.ChipAuthenticationInfo]
  final public let chipAuthenticationPublicKeyInfos: [KinegramEmrtd.ChipAuthenticationPublicKeyInfo]
  final public let activeAuthenticationInfos: [KinegramEmrtd.ActiveAuthenticationInfo]
  final public let terminalAuthenticationInfos: [KinegramEmrtd.SecurityInfo]
  final public let unknownSecurityInfos: [KinegramEmrtd.SecurityInfo]
  @objc deinit
}
@_hasMissingDesignatedInitializers public class DataGroup14File : KinegramEmrtd.File {
  final public let paceInfos: [KinegramEmrtd.PaceInfo]
  final public let paceDomainParameterInfos: [KinegramEmrtd.PaceDomainParameterInfo]
  final public let chipAuthenticationInfos: [KinegramEmrtd.ChipAuthenticationInfo]
  final public let chipAuthenticationPublicKeyInfos: [KinegramEmrtd.ChipAuthenticationPublicKeyInfo]
  final public let activeAuthenticationInfos: [KinegramEmrtd.ActiveAuthenticationInfo]
  final public let terminalAuthenticationInfos: [KinegramEmrtd.SecurityInfo]
  final public let unknownSecurityInfos: [KinegramEmrtd.SecurityInfo]
  @objc deinit
}
@_hasMissingDesignatedInitializers public class DataGroup15File : KinegramEmrtd.File {
  final public let publicKey: Swift.OpaquePointer
  @objc deinit
}
public enum DocumentType : Swift.Int {
  case TD1
  case TD2
  case TD3
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class DataGroup1File : KinegramEmrtd.File {
  final public let documentType: KinegramEmrtd.DocumentType
  final public let documentCode: Swift.String
  final public let issuingState: Swift.String
  final public let primaryIdentifier: Swift.String
  final public let secondaryIdentifier: Swift.String
  final public let nationality: Swift.String
  final public let documentNumber: Swift.String
  final public let dateOfBirth: Foundation.Date?
  final public let dateOfBirthRawString: Swift.String
  final public let gender: Swift.Character?
  final public let dateOfExpiry: Foundation.Date
  final public let documentNumberCheckDigit: Swift.Character
  final public let dateOfBirthCheckDigit: Swift.Character
  final public let dateOfExpiryCheckDigit: Swift.Character
  final public let compositeCheckDigit: Swift.Character
  final public let optionalData1: Swift.String?
  final public let optionalData2: Swift.String?
  @objc deinit
}
@_hasMissingDesignatedInitializers public class DataGroup2File : KinegramEmrtd.File {
  final public let biometricInfos: [KinegramEmrtd.BiometricInformation<KinegramEmrtd.BiometricFace>]
  public var faceInfos: [KinegramEmrtd.BiometricFaceImageInfo]? {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class DataGroup11File : KinegramEmrtd.File {
  public var fullNameOfDocumentHolder: (primaryIdentifier: Swift.String?, secondaryIdentifier: Swift.String?) {
    get
  }
  public var otherNames: [Swift.String]? {
    get
  }
  public var personalNumber: Swift.String? {
    get
  }
  public var fullDateOfBirth: Foundation.Date? {
    get
  }
  public var placeOfBirth: Swift.String? {
    get
  }
  public var permanentAddress: Swift.String? {
    get
  }
  public var telephone: Swift.String? {
    get
  }
  public var profession: Swift.String? {
    get
  }
  public var title: Swift.String? {
    get
  }
  public var personalSummary: Swift.String? {
    get
  }
  public var proofOfCitizinShipRawImageData: [Swift.UInt8]? {
    get
  }
  public var proofOfCitizinShipUIImage: UIKit.UIImage? {
    get
  }
  public var otherValidTravelDocumentNumbers: [Swift.String]? {
    get
  }
  public var custodyInformation: Swift.String? {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class DataGroup12File : KinegramEmrtd.File {
  public var issuingAuthority: Swift.String? {
    get
  }
  public var dateOfIssue: Foundation.Date? {
    get
  }
  public var otherPersonNames: [Swift.String]? {
    get
  }
  public var endorsementsObservations: Swift.String? {
    get
  }
  public var taxExitRequirements: Swift.String? {
    get
  }
  public var frontOfDocumentRawImageData: [Swift.UInt8]? {
    get
  }
  public var frontOfDocumentUIImage: UIKit.UIImage? {
    get
  }
  public var rearOfDocumentRawImageData: [Swift.UInt8]? {
    get
  }
  public var rearOfDocumentUIImage: UIKit.UIImage? {
    get
  }
  public var dateAndTimeOfDocumentPersonalization: Swift.String? {
    get
  }
  public var serialNumberOfPersonalizationSystem: Swift.String? {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class DataGroup7File : KinegramEmrtd.File {
  final public let signatureImagesRawData: [[Swift.UInt8]]
  final public let signatureUIImages: [UIKit.UIImage?]
  @objc deinit
}
public class MasterlistFile {
  final public let masterlistSignerCertificate: KinegramEmrtd.X509Wrapper
  public init(fileUrl: Foundation.URL, issuerCertificateUrl: Foundation.URL? = nil) throws
  public func getCertificates() -> [KinegramEmrtd.X509Wrapper]
  @objc deinit
}
public typealias LDSSecurityObject = (version: KinegramEmrtd.ASN1Integer, hashAlgorithmObjectIdentifier: KinegramEmrtd.ASN1ObjectIdentifier, hashAlgorithm: KinegramEmrtd.HashAlgorithm, hashes: [KinegramEmrtd.ASN1Integer : [Swift.UInt8]], ldsVersionInfo: KinegramEmrtd.LDSVersionInfo?)
public typealias DataGroupHash = (datagroupNumber: KinegramEmrtd.ASN1Integer, hashValue: [Swift.UInt8])
public typealias LDSVersionInfo = (ldsVersion: Swift.String, unicodeVersion: Swift.String)
public enum HashAlgorithm : Swift.String {
  case MD2
  case MD5
  case SHA1
  case SHA256
  case SHA384
  case SHA512
  case Unknown
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class SODFile : KinegramEmrtd.File {
  final public let documentCertificate: KinegramEmrtd.X509Wrapper
  final public let signatureValid: Swift.Bool
  final public let ldsSecurityObject: KinegramEmrtd.LDSSecurityObject
  public var availableElementaryFiles: [KinegramEmrtd.ElementaryFileName] {
    get
  }
  public init(data: [Swift.UInt8]) throws
  public func getHashValue(for otherFileName: KinegramEmrtd.ElementaryFileName) -> [Swift.UInt8]?
  @objc deinit
}
public typealias SecurityInfo = (protocol: KinegramEmrtd.ASN1ObjectIdentifier, required: KinegramEmrtd.ASN1TLV, optional: KinegramEmrtd.ASN1TLV?)
public enum CryptographicAlgorithm : Swift.String {
  case TripleDES_CBC_CBC
  case AES_CBC_CMAC_128
  case AES_CBC_CMAC_192
  case AES_CBC_CMAC_256
  case Unknown
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum SignatureAlgorithmECDSA : Swift.String {
  case SHA1
  case SHA224
  case SHA256
  case SHA384
  case SHA512
  case RIPEMD160
  case SHA3_224
  case SHA3_256
  case SHA3_384
  case SHA3_512
  case Unknown
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public typealias ActiveAuthenticationInfo = (protocolObjectIdentifier: KinegramEmrtd.ASN1ObjectIdentifier, version: KinegramEmrtd.ASN1Integer, signatureAlgorithmObjectIdentifier: KinegramEmrtd.ASN1ObjectIdentifier, plainECDSASignatureAlgorithm: KinegramEmrtd.SignatureAlgorithmECDSA)
public enum ChipAuthenticationKeyAgreementType : Swift.String {
  case DH
  case ECDH
  case Unknown
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public typealias ChipAuthenticationInfo = (protocolObjectIdentifier: KinegramEmrtd.ASN1ObjectIdentifier, keyAgreementType: KinegramEmrtd.ChipAuthenticationKeyAgreementType, algorithm: KinegramEmrtd.CryptographicAlgorithm, version: KinegramEmrtd.ASN1Integer, keyId: KinegramEmrtd.ASN1Integer?)
public typealias ChipAuthenticationPublicKeyInfo = (protocolObjectIdentifier: KinegramEmrtd.ASN1ObjectIdentifier, keyAgreementType: KinegramEmrtd.ChipAuthenticationKeyAgreementType, publicKey: KinegramEmrtd.PublicKeyWrapper, keyId: KinegramEmrtd.ASN1Integer?)
@_hasMissingDesignatedInitializers public class PublicKeyWrapper : Swift.CustomStringConvertible {
  @objc deinit
  public var description: Swift.String {
    get
  }
}
public enum StandardizedDomainParameter : Swift.Int64 {
  case GFP_1024_160
  case GFP_2048_224
  case GFP_2048_256
  case ECP_NIST_P192_R1
  case ECP_BRAINPOOL_P192_R1
  case ECP_NIST_P224_R1
  case ECP_BRAINPOOL_P224_R1
  case ECP_NIST_P256_R1
  case ECP_BRAINPOOL_P256_R1
  case ECP_BRAINPOOL_P320_R1
  case ECP_NIST_P384_R1
  case ECP_BRAINPOOL_P384_R1
  case ECP_BRAINPOOL_P512_R1
  case ECP_NIST_P521_R1
  public init?(rawValue: Swift.Int64)
  public typealias RawValue = Swift.Int64
  public var rawValue: Swift.Int64 {
    get
  }
}
public enum PaceMappingType : Swift.String {
  case DH_GM
  case EC_DH_GM
  case DH_IM
  case EC_DH_IM
  case EC_DH_CAM
  case Unknown
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public typealias PaceInfo = (protocolObjectIdentifier: KinegramEmrtd.ASN1ObjectIdentifier, mappingType: KinegramEmrtd.PaceMappingType, algorithm: KinegramEmrtd.CryptographicAlgorithm, version: KinegramEmrtd.ASN1Integer, parameterId: KinegramEmrtd.ASN1Integer?)
public typealias PaceDomainParameterInfo = (protocolObjectIdentifier: KinegramEmrtd.ASN1ObjectIdentifier, paceMappingType: KinegramEmrtd.PaceMappingType, domainParameter: KinegramEmrtd.ASN1ObjectIdentifier, parameterId: KinegramEmrtd.ASN1Integer?)
@_documentation(visibility: internal) public struct AccessKeyInfo : Swift.Codable, Swift.Sendable {
  public enum KeyType : Swift.String, Swift.Codable, Swift.Sendable {
    case mrz
    case can
    case unknown
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let type: KinegramEmrtd.AccessKeyInfo.KeyType
  public let documentNumber: Swift.String?
  public let dateOfBirth: Swift.String?
  public let dateOfExpiry: Swift.String?
  public let can: Swift.String?
  public init(documentNumber: Swift.String, dateOfBirth: Swift.String, dateOfExpiry: Swift.String)
  public init(can: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_documentation(visibility: internal) public struct SecureMessagingInfo : Swift.Codable, Swift.Sendable {
  public let algorithm: Swift.String
  public let encKey: Swift.String
  public let macKey: Swift.String
  public let ssc: Swift.Int
  public init(algorithm: Swift.String, encKey: Swift.String, macKey: Swift.String, ssc: Swift.Int)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_documentation(visibility: internal) public struct HandoverState : Swift.Codable, Swift.Sendable {
  public let secureMessagingInfo: KinegramEmrtd.SecureMessagingInfo
  public let maxTransceiveLength: Swift.Int
  public let maxBlockSize: Swift.Int
  public let filesRead: [KinegramEmrtd.ElementaryFileName : Foundation.Data]
  public let accessKeyInfo: KinegramEmrtd.AccessKeyInfo
  public let activeAuthChallenge: Foundation.Data?
  public let caHandoverData: KinegramEmrtd.CAHandoverData?
  public let sessionId: Swift.String?
  public init(secureMessagingInfo: KinegramEmrtd.SecureMessagingInfo, maxTransceiveLength: Swift.Int, maxBlockSize: Swift.Int, filesRead: [KinegramEmrtd.ElementaryFileName : Foundation.Data], accessKeyInfo: KinegramEmrtd.AccessKeyInfo, activeAuthChallenge: Foundation.Data? = nil, caHandoverData: KinegramEmrtd.CAHandoverData? = nil, sessionId: Swift.String? = nil)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_documentation(visibility: internal) public enum CACheckResult : Swift.String, Swift.Codable, Swift.Sendable {
  case success
  case failed
  case unavailable
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_documentation(visibility: internal) public struct CAHandbackInfo : Swift.Codable, Swift.Sendable {
  public let checkResult: KinegramEmrtd.CACheckResult
  public let secureMessagingInfo: KinegramEmrtd.SecureMessagingInfo?
  public let dg1Data: Foundation.Data?
  public init(checkResult: KinegramEmrtd.CACheckResult, secureMessagingInfo: KinegramEmrtd.SecureMessagingInfo? = nil, dg1Data: Foundation.Data? = nil)
  public init(checkResult: Swift.String, secureMessagingInfo: KinegramEmrtd.SecureMessagingInfo? = nil, dg1Data: Foundation.Data? = nil)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_documentation(visibility: internal) public protocol APDURelayHandler : AnyObject {
  func sendAPDUCommand(_ command: Foundation.Data) async throws -> Foundation.Data
}
@_documentation(visibility: internal) public struct CAHandoverData : Swift.Codable, Swift.Sendable {
  public let chipPublicKey: Foundation.Data
  public let ephemeralPublicKey: Foundation.Data
  public let keyIdRef: Foundation.Data?
  public let algorithm: Swift.String
  public let protocolOID: Swift.String?
  public init(chipPublicKey: Foundation.Data, ephemeralPublicKey: Foundation.Data, keyIdRef: Foundation.Data? = nil, algorithm: Swift.String, protocolOID: Swift.String? = nil)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_documentation(visibility: internal) public struct DataGroupSet : Swift.OptionSet, Swift.Sendable {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  public static let dg1: KinegramEmrtd.DataGroupSet
  public static let dg2: KinegramEmrtd.DataGroupSet
  public static let dg3: KinegramEmrtd.DataGroupSet
  public static let dg4: KinegramEmrtd.DataGroupSet
  public static let dg5: KinegramEmrtd.DataGroupSet
  public static let dg6: KinegramEmrtd.DataGroupSet
  public static let dg7: KinegramEmrtd.DataGroupSet
  public static let dg8: KinegramEmrtd.DataGroupSet
  public static let dg9: KinegramEmrtd.DataGroupSet
  public static let dg10: KinegramEmrtd.DataGroupSet
  public static let dg11: KinegramEmrtd.DataGroupSet
  public static let dg12: KinegramEmrtd.DataGroupSet
  public static let dg13: KinegramEmrtd.DataGroupSet
  public static let dg14: KinegramEmrtd.DataGroupSet
  public static let dg15: KinegramEmrtd.DataGroupSet
  public static let dg16: KinegramEmrtd.DataGroupSet
  public static let all: KinegramEmrtd.DataGroupSet
  public static let standard: KinegramEmrtd.DataGroupSet
  public typealias ArrayLiteralElement = KinegramEmrtd.DataGroupSet
  public typealias Element = KinegramEmrtd.DataGroupSet
  public typealias RawValue = Swift.Int
}
public enum ElementaryFileName : Swift.Int64, Swift.CaseIterable, Swift.Codable, Swift.Sendable {
  case COM
  case DG1
  case DG2
  case DG3
  case DG4
  case DG5
  case DG6
  case DG7
  case DG8
  case DG9
  case DG10
  case DG11
  case DG12
  case DG13
  case DG14
  case DG15
  case DG16
  case SOD
  case CardAccess
  case AtrInfo
  @_documentation(visibility: internal) public var protocolName: Swift.String {
    get
  }
  public init?(rawValue: Swift.Int64)
  public typealias AllCases = [KinegramEmrtd.ElementaryFileName]
  public typealias RawValue = Swift.Int64
  nonisolated public static var allCases: [KinegramEmrtd.ElementaryFileName] {
    get
  }
  public var rawValue: Swift.Int64 {
    get
  }
}
public enum EmrtdChipCommunicationError : KinegramEmrtd.ErrorWithMonitoringInfo {
  case APDUResponseError(sw1: Swift.UInt8, sw2: Swift.UInt8)
  case SecureMessagingProtectFailed(any Swift.Error)
  case SecureMessagingUnprotectFailed(any Swift.Error)
  case UnexpectedFileFormat(any Swift.Error)
  case NFCError(CoreNFC.NFCReaderError)
  case UnexpectedError(_: (any Swift.Error)? = nil)
  case ReadBinaryOffsetTooLarge(totalFileSize: Swift.Int)
  public var monitoringText: Swift.String {
    get
  }
}
@available(*, deprecated, message: "Intelligent Database Message is used with Document Validation Server REST API v3. REST API v3 is deprecated. Please use API v4.")
public struct IntelligentDatabaseMessageBuilder {
  public init(app: Swift.String)
  public func encodeAsJSON(emrtdResult: KinegramEmrtd.EmrtdResult?, error: KinegramEmrtd.EmrtdReaderError? = nil) throws -> Foundation.Data
}
public protocol MonitoringDelegate : AnyObject {
  func onNewMonitoringEvent(message: Swift.String)
}
extension KinegramEmrtd.EmrtdReader {
  public func setMonitoringDelegate(_ delegate: any KinegramEmrtd.MonitoringDelegate)
}
public enum ActiveAuthenticationFailedReason : KinegramEmrtd.ErrorWithMonitoringInfo, Swift.Equatable {
  case FailedToGenerateChallenge
  case ChipInternalAuthenticationFailed(Swift.String)
  case VerifyFailed(Swift.String)
  case InvalidRSASignature(Swift.String)
  case UnsupportedHashAlgorithm
  case Unknown
  public var monitoringText: Swift.String {
    get
  }
  public static func == (a: KinegramEmrtd.ActiveAuthenticationFailedReason, b: KinegramEmrtd.ActiveAuthenticationFailedReason) -> Swift.Bool
}
public enum ChipAccessType : Swift.String {
  case BasicAccessControl
  case PasswordAuthenticatedConnectionEstablishment
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ChipAuthenticationFailedReason : KinegramEmrtd.ErrorWithMonitoringInfo, Swift.Equatable {
  case AlgorithmNotSupported
  case NoChipAuthenticationPublicKeyInfoFound
  case FailedToGenerateKeyPair(Swift.String)
  case FailedToSetKeyAgreementTemplate(Swift.String)
  case FailedToSetAuthenticationTemplate(Swift.String)
  case FailedToGeneralAuthenticate(Swift.String)
  case FailedToDeriveSharedSecret(Swift.String)
  case SecureMessagingFailedAfterCA
  case Unknown
  public var monitoringText: Swift.String {
    get
  }
  public static func == (a: KinegramEmrtd.ChipAuthenticationFailedReason, b: KinegramEmrtd.ChipAuthenticationFailedReason) -> Swift.Bool
}
public enum PassiveAuthenticationError : KinegramEmrtd.ErrorWithMonitoringInfo {
  case SODFileIsMissing
  case VerifyTrustFailed(any Swift.Error)
  case FailedToInitTrustStore(any Swift.Error)
  case UnknownHashFunction
  public var monitoringText: Swift.String {
    get
  }
}
public struct KinegramEmrtdInfo {
  public static let version: Swift.String
  public static let buildVersion: Swift.String
  public init()
  public static func printVersions()
}
extension KinegramEmrtd.ASN1TagClass : Swift.Equatable {}
extension KinegramEmrtd.ASN1TagClass : Swift.Hashable {}
extension KinegramEmrtd.ASN1TagClass : Swift.RawRepresentable {}
extension KinegramEmrtd.CryptographicAlgorithm : Swift.Equatable {}
extension KinegramEmrtd.CryptographicAlgorithm : Swift.Hashable {}
extension KinegramEmrtd.CryptographicAlgorithm : Swift.RawRepresentable {}
@available(*, deprecated, message: "Access the X509Wrapper properties instead.")
extension KinegramEmrtd.CertificateItem : Swift.Equatable {}
@available(*, deprecated, message: "Access the X509Wrapper properties instead.")
extension KinegramEmrtd.CertificateItem : Swift.Hashable {}
@available(*, deprecated, message: "Access the X509Wrapper properties instead.")
extension KinegramEmrtd.CertificateItem : Swift.RawRepresentable {}
extension KinegramEmrtd.Gender : Swift.Equatable {}
extension KinegramEmrtd.Gender : Swift.Hashable {}
extension KinegramEmrtd.Gender : Swift.RawRepresentable {}
extension KinegramEmrtd.EyeColor : Swift.Equatable {}
extension KinegramEmrtd.EyeColor : Swift.Hashable {}
extension KinegramEmrtd.EyeColor : Swift.RawRepresentable {}
extension KinegramEmrtd.HairColor : Swift.Equatable {}
extension KinegramEmrtd.HairColor : Swift.Hashable {}
extension KinegramEmrtd.HairColor : Swift.RawRepresentable {}
extension KinegramEmrtd.Features.Flag : Swift.Equatable {}
extension KinegramEmrtd.Features.Flag : Swift.Hashable {}
extension KinegramEmrtd.Features.Flag : Swift.RawRepresentable {}
extension KinegramEmrtd.Expression : Swift.Equatable {}
extension KinegramEmrtd.Expression : Swift.Hashable {}
extension KinegramEmrtd.Expression : Swift.RawRepresentable {}
extension KinegramEmrtd.FaceImageType : Swift.Equatable {}
extension KinegramEmrtd.FaceImageType : Swift.Hashable {}
extension KinegramEmrtd.FaceImageType : Swift.RawRepresentable {}
extension KinegramEmrtd.ImageDataType : Swift.Equatable {}
extension KinegramEmrtd.ImageDataType : Swift.Hashable {}
extension KinegramEmrtd.ImageDataType : Swift.RawRepresentable {}
extension KinegramEmrtd.ColorSpace : Swift.Equatable {}
extension KinegramEmrtd.ColorSpace : Swift.Hashable {}
extension KinegramEmrtd.ColorSpace : Swift.RawRepresentable {}
extension KinegramEmrtd.SourceType : Swift.Equatable {}
extension KinegramEmrtd.SourceType : Swift.Hashable {}
extension KinegramEmrtd.SourceType : Swift.RawRepresentable {}
extension KinegramEmrtd.BiometricError : Swift.Equatable {}
extension KinegramEmrtd.BiometricError : Swift.Hashable {}
extension KinegramEmrtd.DocumentType : Swift.Equatable {}
extension KinegramEmrtd.DocumentType : Swift.Hashable {}
extension KinegramEmrtd.DocumentType : Swift.RawRepresentable {}
extension KinegramEmrtd.HashAlgorithm : Swift.Equatable {}
extension KinegramEmrtd.HashAlgorithm : Swift.Hashable {}
extension KinegramEmrtd.HashAlgorithm : Swift.RawRepresentable {}
extension KinegramEmrtd.SignatureAlgorithmECDSA : Swift.Equatable {}
extension KinegramEmrtd.SignatureAlgorithmECDSA : Swift.Hashable {}
extension KinegramEmrtd.SignatureAlgorithmECDSA : Swift.RawRepresentable {}
extension KinegramEmrtd.ChipAuthenticationKeyAgreementType : Swift.Equatable {}
extension KinegramEmrtd.ChipAuthenticationKeyAgreementType : Swift.Hashable {}
extension KinegramEmrtd.ChipAuthenticationKeyAgreementType : Swift.RawRepresentable {}
extension KinegramEmrtd.StandardizedDomainParameter : Swift.Equatable {}
extension KinegramEmrtd.StandardizedDomainParameter : Swift.Hashable {}
extension KinegramEmrtd.StandardizedDomainParameter : Swift.RawRepresentable {}
extension KinegramEmrtd.PaceMappingType : Swift.Equatable {}
extension KinegramEmrtd.PaceMappingType : Swift.Hashable {}
extension KinegramEmrtd.PaceMappingType : Swift.RawRepresentable {}
extension KinegramEmrtd.AccessKeyInfo.KeyType : Swift.Equatable {}
extension KinegramEmrtd.AccessKeyInfo.KeyType : Swift.Hashable {}
extension KinegramEmrtd.AccessKeyInfo.KeyType : Swift.RawRepresentable {}
extension KinegramEmrtd.CACheckResult : Swift.Equatable {}
extension KinegramEmrtd.CACheckResult : Swift.Hashable {}
extension KinegramEmrtd.CACheckResult : Swift.RawRepresentable {}
extension KinegramEmrtd.ElementaryFileName : Swift.Equatable {}
extension KinegramEmrtd.ElementaryFileName : Swift.Hashable {}
extension KinegramEmrtd.ElementaryFileName : Swift.RawRepresentable {}
extension KinegramEmrtd.ChipAccessType : Swift.Equatable {}
extension KinegramEmrtd.ChipAccessType : Swift.Hashable {}
extension KinegramEmrtd.ChipAccessType : Swift.RawRepresentable {}
